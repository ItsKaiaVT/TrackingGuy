"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dispatcher = void 0;
const rxjs_1 = require("rxjs");
const redis_observable_1 = require("redis-observable");
let Dispatcher = (() => {
    class Dispatcher {
        constructor() {
            this.handlers = [];
            this.chose = (param, handler_name = null) => {
                for (const handler of this.handlers) {
                    if (handler.legal(param) &&
                        (handler_name ? handler.name === handler_name : true)) {
                        return handler;
                    }
                }
                return null;
            };
            this.push = (source, handler_name) => {
                return (this.getHandler(handler_name) || {
                    push: () => rxjs_1.of(null),
                }).push(source);
            };
            this.query = (param, force = true, handler_name = null) => {
                const handler = this.chose(param, handler_name);
                if (!handler) {
                    console.error('HANDLER NOT FOUND', JSON.stringify(param));
                    return rxjs_1.of(null);
                }
                if (handler.webhook && !force) {
                    return handler.put(param);
                }
                return handler.query(param, force);
            };
            this.getHandlerName = () => {
                return this.handlers.map(i => i.name);
            };
            this.getHandler = (handler_name) => {
                for (const handler of this.handlers) {
                    if (handler.name === handler_name) {
                        return handler;
                    }
                }
                return null;
            };
            this.getConfig = () => {
                return Object.fromEntries(this.handlers.map(i => [i.name, i.getConfig()]));
            };
            this.setConfig = (handler_name, option) => {
                const handler = this.getHandler(handler_name);
                if (handler) {
                    handler.setConfig(option);
                    return handler.getConfig()[handler.name];
                }
                return null;
            };
        }
    }
    Dispatcher.register = async (creator, config) => {
        if (!Dispatcher.instance) {
            throw new Error('Must create a Dispatcher instance');
        }
        for (const handler of Dispatcher.instance.handlers) {
            if (handler.name === config.name) {
                handler.setConfig(config);
                return;
            }
        }
        const handler = new creator({ redis: Dispatcher.redis, config });
        await handler.init().toPromise();
        Dispatcher.instance.handlers.push(handler);
        Dispatcher.instance.handlers = Dispatcher.instance.handlers.sort((a, b) => b.weight - a.weight);
        return;
    };
    Dispatcher.create = (redisOpt) => {
        if (Dispatcher.instance) {
            return Dispatcher.instance;
        }
        if (!Dispatcher.redis) {
            Dispatcher.redis =
                redisOpt instanceof redis_observable_1.RxRedis ? redisOpt : new redis_observable_1.RxRedis(redisOpt);
        }
        Dispatcher.instance = new Dispatcher();
        return Dispatcher.instance;
    };
    return Dispatcher;
})();
exports.Dispatcher = Dispatcher;
//# sourceMappingURL=dispatcher.js.map