"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const gulp_1 = require("gulp");
const through2 = require("through2");
const rename = require("gulp-rename");
const json_to_ts_1 = require("json-to-ts");
const index_1 = require("./index");
const remote_config_1 = require("@jsdvjx/remote-config");
const IQuerist_1 = require("./Queries/IQuerist");
const config = () => {
    // 创建stream对象，每个文件都会经过这个stream对象
    const stream = through2.obj(async function (chunk, _, callback) {
        this.push(chunk);
        const rc = await remote_config_1.RemoteConfig.create(chunk.path);
        const query = rc.map['query'];
        const sf = index_1.QueryFun.create(query.path, query.format);
        const conf = query.databases.reduce((result, path) => {
            const options = rc.map[path];
            if (options instanceof Array) {
                return result.concat(options);
            }
            else if (options.tag && options.type) {
                result.push(options);
            }
            return result;
        }, []);
        for (const option of conf) {
            await index_1.QueryFun.register(IQuerist_1.IQuerist.create(option));
        }
        const info = await sf.exportInterface();
        chunk.contents = Buffer.from(json_to_ts_1.default(info, { rootName: 'IQueryFun' })
            .map(s => `export ${s.replace(/\?: any/g, ': void')}`)
            .join('\n'));
        callback(null, chunk);
        rc.close();
        sf.close();
    });
    return stream;
};
const getPath = () => {
    const idx = process.argv.indexOf('--src');
    if (idx > 0) {
        return process.argv[idx + 1];
    }
    return process.env.CONFIG_PATH || './config/config.develop.yaml';
};
const path = getPath();
const getConfigInterface = () => {
    return gulp_1.src(path)
        .pipe(config())
        .pipe(rename('query-fun.d.ts'))
        .pipe(gulp_1.dest('src'));
};
gulp_1.task('build:query', getConfigInterface);
//exports.buildConfig = getConfigInterface;
