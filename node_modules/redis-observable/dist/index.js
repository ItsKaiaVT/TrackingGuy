"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const redis = __importStar(require("redis"));
const rxjs_1 = require("rxjs");
var TTLMode;
(function (TTLMode) {
    TTLMode["SECOND"] = "EX";
    TTLMode["MILLISECOND"] = "PX";
})(TTLMode = exports.TTLMode || (exports.TTLMode = {}));
var InsertMode;
(function (InsertMode) {
    InsertMode["INSERT_WHEN_NOT_EXIST"] = "NX";
    InsertMode["INSERT_WHEN_EXIST"] = "XX";
})(InsertMode = exports.InsertMode || (exports.InsertMode = {}));
class RxRedis {
    constructor(options) {
        this.options = options;
        this.client = redis.createClient(this.options);
        this.curry = (handler) => {
            //@ts-ignore
            return ((...args) => {
                return new rxjs_1.Observable((obser) => {
                    const cb = (error, reply) => {
                        if (error) {
                            obser.error(error);
                        }
                        else {
                            obser.next(reply);
                        }
                        obser.complete();
                    };
                    handler(...args, cb);
                });
            });
        };
        this.get = this.curry(this.client.get.bind(this.client));
        this.getset = this.curry(this.client.getset.bind(this.client));
        this.strlen = this.curry(this.client.strlen.bind(this.client));
        this.append = this.curry(this.client.append.bind(this.client));
        this.setrange = this.curry(this.client.setrange.bind(this.client));
        this.getrange = this.curry(this.client.getrange.bind(this.client));
        this.incr = this.curry(this.client.incr.bind(this.client));
        this.incrby = this.curry(this.client.incrby.bind(this.client));
        this.incrbyfloat = this.curry(this.client.incrbyfloat.bind(this.client));
        this.decr = this.curry(this.client.decr.bind(this.client));
        this.decrby = this.curry(this.client.decrby.bind(this.client));
        this.lpushx = this.curry(this.client.lpushx.bind(this.client));
        this.rpushx = this.curry(this.client.rpushx.bind(this.client));
        this.rpoplpush = this.curry(this.client.rpoplpush.bind(this.client));
        this.rpop = this.curry(this.client.rpop.bind(this.client));
        this.lpop = this.curry(this.client.lpop.bind(this.client));
        this.lrem = this.curry(this.client.lrem.bind(this.client));
        this.llen = this.curry(this.client.llen.bind(this.client));
        this.lindex = this.curry(this.client.lindex.bind(this.client));
        this.linsert = this.curry(this.client.linsert.bind(this.client));
        this.lset = this.curry(this.client.lset.bind(this.client));
        this.lrange = this.curry(this.client.lrange.bind(this.client));
        this.ltrim = this.curry(this.client.ltrim.bind(this.client));
        this.brpoplpush = this.curry(this.client.brpoplpush.bind(this.client));
        this.innser_set = this.curry(this.client.set.bind(this.client));
        this.publish = this.curry(this.client.publish.bind(this.client));
        this.set = (key, value, ttl, ttlMode, insertMode) => {
            if (ttl != undefined) {
                if (ttl > 0 && ttl != null) {
                    return this.innser_set(...(insertMode ? [key, value, ttlMode || 'EX', ttl, insertMode] : [key, value, ttlMode || 'EX', ttl]));
                }
                else {
                    return this.innser_set(...(insertMode ? [key, value] : [key, value, insertMode]));
                }
            }
            return this.innser_set(key, value);
        };
        this._set = this.set;
        this.setnx = (key, value) => {
            return this._set(key, value, 0, undefined, InsertMode.INSERT_WHEN_NOT_EXIST);
        };
        this.setex = (key, value, ttl) => {
            return this._set(key, value, ttl, TTLMode.SECOND);
        };
        this.psetex = (key, value, ttl) => {
            return this._set(key, value, ttl, TTLMode.MILLISECOND);
        };
        this.mset = (...pairs) => {
            return this.curry(this.client.mset.bind(this.client))(...pairs.reduce((res, acc) => [...res, ...acc], []));
        };
        this.msetnx = (...pairs) => {
            return this.curry(this.client.msetnx.bind(this.client))(...pairs.reduce((res, acc) => [...res, ...acc], []));
        };
        this.mget = (...keys) => {
            return this.curry(this.client.mget.bind(this.client))(...keys);
        };
        this.lpush = (key, ...vals) => {
            return this.curry(this.client.lpush.bind(this.client))(key, ...vals);
        };
        this.rpush = (key, ...vals) => {
            return this.curry(this.client.rpush.bind(this.client))(key, ...vals);
        };
        this.blpop = (keys, timeout = 0) => {
            return this.curry(this.client.blpop.bind(this.client))(...(typeof keys === 'string' ? [keys] : keys), timeout);
        };
        this.brpop = (keys, timeout = 0) => {
            return this.curry(this.client.brpop.bind(this.client))(...(typeof keys === 'string' ? [keys] : keys), timeout);
        };
        this.message$ = new rxjs_1.Observable((obser) => {
            this.client.on("message", (channel, message) => {
                obser.next({ channel, message });
            });
            this.client.on("unsubscribe", (_, count) => {
                if (count === 0) {
                    obser.complete();
                }
            });
        });
        this.subscribe = (...channels) => {
            this.client.subscribe(...channels);
            return this.message$.subscribe.bind(this.message$);
        };
        this.unsubscribe = (...channels) => {
            this.client.unsubscribe(...channels);
        };
    }
}
exports.RxRedis = RxRedis;
