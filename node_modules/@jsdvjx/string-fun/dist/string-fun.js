"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringFun = void 0;
const moment = require("moment");
const fs_1 = require("fs");
class StringFun {
    constructor(templates) {
        this.templates = templates;
        this.initOptions = (templates) => {
            this.options = templates
                .map(temp => [temp.name, this.template2option(temp)])
                .reduce((result, [name, option]) => {
                return (result[name] = option), result;
            }, {});
            return this.options;
        };
        this.initCaller = (options) => {
            this.caller = Object.entries(options).reduce((result, [name]) => {
                return (result[name] = this.createFun(name)), result;
            }, {});
            return this.caller;
        };
        this.template2option = (template) => {
            const _template = this.removeComment(template.template);
            const sub = this.getSubTemplate(_template);
            return {
                name: template.name,
                source: template.template,
                template: _template,
                params: this.extract(_template),
                loop: !!sub,
                ...(sub || {}),
            };
        };
        this.extract = (template) => {
            const p = /\{[a-zA-Z_]\w*?[ ]*?:[ ]*?(number|string|date|bigint|boolean)(|[ ]*?\=[ ]*?.+?)\}/g;
            const _p = /\{[a-zA-Z_]\w*?\}/g;
            const tmps = (template.match(p) || []).concat((template.match(_p) || []).map(i => `{${i.substring(1).substring(0, i.length - 2)}:string}`));
            const exists = {};
            const split = (str) => str
                .substring(1)
                .substring(0, str.length - 2)
                .trim()
                .split(/[:]/g)
                .map(j => j.trim());
            const transDef = (str) => {
                if (/^("|').*\1/m.test(str)) {
                    return str.substring(1, str.length - 1);
                }
                return str;
            };
            const getDef = (type, val) => {
                switch (type) {
                    case 'number':
                        const result = (/\d+\.\d+/.test(val) ? parseFloat : parseInt)(val);
                        return isNaN(result) ? 0 : result;
                    case 'date':
                        return moment(val, StringFun.format).toDate();
                    case 'boolean':
                        return val === 'true' ? true : false;
                    default:
                        return val;
                }
            };
            const trans = ([name, typeAndDefaul]) => {
                if (exists[name])
                    return false;
                exists[name] = true;
                const idx = typeAndDefaul.indexOf('=');
                const type = idx > 0 ? typeAndDefaul.substring(0, idx) : typeAndDefaul;
                const def = idx > 0 ? transDef(typeAndDefaul.substring(idx + 1).trim()) : undefined;
                return {
                    type,
                    name,
                    ...(def
                        ? {
                            default: getDef(type, def),
                        }
                        : {}),
                };
            };
            return tmps
                ? tmps
                    .map(split)
                    .map(trans)
                    .filter(i => !!i)
                : [];
        };
        this.getSubTemplate = (template) => {
            const x = /\{\$LOOP:(?<subTemplate>.+?),\$JOIN:(?<separation>.+?)}/.exec(template);
            return x ? x.groups : null;
        };
        this.removeComment = (template) => {
            return template.replace(/\/\*[\w\W]*?\*\//g, '');
        };
        this.demoMap = {
            number: 1,
            bigint: 1n,
            string: '1',
            date: new Date(),
            boolean: true,
        };
        this.createFun = (name) => {
            return param => {
                const option = this.options[name];
                if (!option.loop)
                    return StringFun.replace(option.template, option.params, param);
                return option.template.replace(/{\$[\w\W]+,\$[\w\W]+?}/, param
                    .map(p => StringFun.replace(option.subTemplate, option.params, p))
                    .join(option.separation));
            };
        };
        this.getDefaultParam = () => {
            return Object.fromEntries(Object.entries(this.options).map(([key, template]) => {
                const value = template.params.reduce((res, p) => {
                    if (p.default !== undefined)
                        res[p.name] = p.default;
                    return res;
                }, {});
                return [key, template.loop ? [value] : value];
            }));
        };
        //console.log(this.extract());
        this.initCaller(this.initOptions(this.templates));
    }
    get demo() {
        return Object.values(this.options).reduce((result, { name, params, loop }) => {
            if (params.length === 1) {
                result[name] = this.demoMap[params.pop().type];
            }
            else if (params.length === 0) {
                result[name] = null;
            }
            else
                result[name] = params.reduce((_res, p) => ((_res[p.name] = this.demoMap[p.type]), _res), {});
            if (loop) {
                result[name] = [result[name]];
            }
            return result;
        }, {});
    }
}
exports.StringFun = StringFun;
StringFun.create = (path) => {
    if (StringFun.instance) {
        return StringFun.instance;
    }
    return ((StringFun.instance = new StringFun((fs_1.readdirSync(path) || [])
        .map(i => {
        const _path = `${path}/${i}`;
        return JSON.parse(fs_1.statSync(_path).isFile() ? fs_1.readFileSync(_path).toString() : '[]');
    })
        .reduce((res, acc) => {
        return res.concat(acc);
    }, []) || [])),
        StringFun.instance);
};
StringFun.createByTemplate = (templates) => {
    return new StringFun(templates);
};
StringFun.format = 'YYYY-MM-DD HH:mm:SS';
StringFun.replace = (tempalte, params, param) => {
    let result = tempalte;
    for (const item of params) {
        let val = param[item.name] !== undefined
            ? param[item.name]
            : item.default === undefined
                ? ''
                : item.default;
        if (params.length === 1) {
            val = param[item.name] || param || item.default;
        }
        if (val instanceof Date) {
            val = moment(val).format(StringFun.format);
        }
        const reg = StringFun.createReg(item);
        result = result.replace(reg, StringFun.mask(val));
    }
    return StringFun.unmask(result);
};
StringFun.mask = (val) => {
    if (typeof val !== 'string')
        return val;
    if (val.indexOf('{') >= 0) {
        val = val.replace(/\{/g, '1a2b3c;;+');
    }
    if (val.indexOf('}') >= 0) {
        val = val.replace(/\}/g, '1a2b3c;;-');
    }
    return val;
};
StringFun.unmask = (val) => {
    if (val.indexOf('1a2b3c;;+') >= 0) {
        val = val.replace(/1a2b3c;;\+/g, '{');
    }
    if (val.indexOf('1a2b3c;;-') >= 0) {
        val = val.replace(/1a2b3c;;-/g, '}');
    }
    return val;
};
StringFun.createReg = ({ name }) => {
    return new RegExp(`{${name.toString()}.*?}`, 'g');
};
