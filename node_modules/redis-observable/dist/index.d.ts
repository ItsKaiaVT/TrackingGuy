import * as redis from 'redis';
import { Observable } from "rxjs";
declare type RedisP1<T1 = any, R = any> = (p1: T1) => Observable<R>;
declare type RedisP2<T1 = any, T2 = any, R = any> = (p1: T1, p2: T2) => Observable<R>;
declare type RedisP3<T1 = any, T2 = any, T3 = any, R = any> = (p1: T1, p2: T2, p3: T3) => Observable<R>;
declare type RedisP4<T1 = any, T2 = any, T3 = any, T4 = any, R = any> = (p1: T1, p2: T2, p3: T3, p4: T4) => Observable<R>;
export declare enum TTLMode {
    SECOND = "EX",
    MILLISECOND = "PX"
}
export declare enum InsertMode {
    INSERT_WHEN_NOT_EXIST = "NX",
    INSERT_WHEN_EXIST = "XX"
}
export declare class RxRedis {
    private options;
    private client;
    constructor(options: redis.ClientOpts);
    private curry;
    get: RedisP1<string, string>;
    getset: RedisP2<string, string, string>;
    strlen: RedisP1<string, number>;
    append: RedisP1<string, number>;
    setrange: RedisP3<string, number, string, number>;
    getrange: RedisP3<string, number, number, string>;
    incr: RedisP1<string, number>;
    incrby: RedisP2<string, number, number>;
    incrbyfloat: RedisP2<string, number, number>;
    decr: RedisP1<string, number>;
    decrby: RedisP2<string, number, number>;
    lpushx: RedisP2<string, string, number>;
    rpushx: RedisP2<string, string, number>;
    rpoplpush: RedisP2<string, string, string>;
    rpop: RedisP1<string, string>;
    lpop: RedisP1<string, string>;
    lrem: RedisP3<string, number, string, number>;
    llen: RedisP1<string, number>;
    lindex: RedisP2<string, string, number>;
    linsert: RedisP4<string, "BEFORE" | "AFTER", string, string, number>;
    lset: RedisP3<string, number, string, "ok">;
    lrange: RedisP3<string, number, number, string[]>;
    ltrim: RedisP3<string, number, number, "ok">;
    brpoplpush: RedisP3<string, string, number, string>;
    private innser_set;
    publish: RedisP2<string, string, number>;
    set: (key: string, value: any, ttl?: number | undefined, ttlMode?: TTLMode | undefined, insertMode?: InsertMode | undefined) => Observable<any>;
    private _set;
    setnx: (key: string, value: any) => Observable<any>;
    setex: (key: string, value: any, ttl: number) => Observable<any>;
    psetex: (key: string, value: any, ttl: number) => Observable<any>;
    mset: (...pairs: [string, string][]) => Observable<any>;
    msetnx: (...pairs: [string, string][]) => Observable<any>;
    mget: (...keys: string[]) => Observable<any>;
    lpush: (key: string, ...vals: any[]) => Observable<number>;
    rpush: (key: string, ...vals: any[]) => Observable<number>;
    blpop: (keys: string | string[], timeout?: number) => Observable<any>;
    brpop: (keys: string | string[], timeout?: number) => Observable<any>;
    message$: Observable<{
        channel: string;
        message: string;
    }>;
    subscribe: (...channels: string[]) => {
        (observer?: import("rxjs").NextObserver<{
            channel: string;
            message: string;
        }> | import("rxjs").ErrorObserver<{
            channel: string;
            message: string;
        }> | import("rxjs").CompletionObserver<{
            channel: string;
            message: string;
        }> | undefined): import("rxjs").Subscription;
        (next: null | undefined, error: null | undefined, complete: () => void): import("rxjs").Subscription;
        (next: null | undefined, error: (error: any) => void, complete?: (() => void) | undefined): import("rxjs").Subscription;
        (next: (value: {
            channel: string;
            message: string;
        }) => void, error: null | undefined, complete: () => void): import("rxjs").Subscription;
        (next?: ((value: {
            channel: string;
            message: string;
        }) => void) | undefined, error?: ((error: any) => void) | undefined, complete?: (() => void) | undefined): import("rxjs").Subscription;
    };
    unsubscribe: (...channels: string[]) => void;
}
export {};
