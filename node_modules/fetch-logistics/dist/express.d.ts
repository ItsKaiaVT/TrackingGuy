import { Observable } from 'rxjs';
import { RxRedis } from 'redis-observable';
export declare enum ExpressState {
    UNACTIVE = -1,
    NOTFOUND = 0,
    TRANSIT = 1,
    PICKUP = 2,
    DELIVERED = 3,
    EXCEPTION = 4,
    EXPIRED = 5
}
export interface ExpressProcess {
    time: Date;
    content: string;
}
interface LevenshteinResponse {
    steps: number;
    relative: number;
    similarity: number;
}
export interface ExpressInfo<T = any> {
    id: number;
    number: string;
    company: string;
    code: string;
    state: ExpressState;
    source_state: ExpressState;
    guess: boolean;
    data: ExpressProcess[];
    type: string;
    source: T;
    phone: string;
    last_request: number;
    md5: string;
    request_count: number;
    updated_at: Date;
    created_at: Date;
    delivery_time: Date;
}
export interface QueryParam {
    id: number;
    company: string;
    number: string;
    code: string;
    phone: string;
    delivery_time?: Date;
}
export interface SignTemplate {
    regex: RegExp[];
    code: string;
}
export interface ExpressCompanyCode {
    company: string;
    code: string;
}
export interface ExpressPolicy {
    type: 'white' | 'black' | 'none';
    codes: string[];
}
export interface ExpressHandlerOption<T extends Record<string, any>> {
    name: string;
    webhook?: boolean;
    weight?: number;
    rate?: number;
    max_count?: number;
    policy?: ExpressPolicy;
    conf: T;
    signTemplates?: SignTemplate[];
    expire?: number;
    diy_map?: ExpressCompanyCode[];
}
export declare abstract class IExpress<T extends Record<string, any> = any, P = any> {
    private redis;
    config: P;
    constructor(option: {
        redis: RxRedis;
        config: ExpressHandlerOption<P>;
    });
    protected abstract diy_map: ExpressCompanyCode[];
    protected abstract expire: number;
    setConfig: (config: ExpressHandlerOption<P>) => void;
    getConfig: () => ExpressHandlerOption<P>;
    abstract name: string;
    webhook: boolean;
    abstract weight: number;
    protected abstract rate: number;
    protected abstract max_count: number;
    protected abstract getState: (data: T) => ExpressState;
    protected abstract getProcess: (data: T) => ExpressProcess[];
    protected abstract fetch: (param: ExpressInfo<T>) => Observable<T>;
    protected abstract signTemplates: SignTemplate[];
    protected abstract _put: (param: ExpressInfo<T>) => Observable<ExpressInfo<T>>;
    protected abstract checkList: {
        type: 'white' | 'black' | 'none';
        codes: string[];
    };
    legal: (param: QueryParam) => boolean;
    private check;
    put: (param: QueryParam) => Observable<ExpressInfo<T>>;
    query: (param: QueryParam, force?: boolean) => Observable<any>;
    push: (source: T, param?: QueryParam) => Observable<ExpressInfo<T>>;
    private after_convert;
    protected abstract getParamByResponse: (source: T) => QueryParam;
    protected expired: (last_request: number) => boolean;
    protected checkExNu: (param: QueryParam) => boolean;
    protected initExpressInfo: (param: QueryParam) => ExpressInfo<T>;
    getCacheOrInit: (param: QueryParam) => Observable<ExpressInfo<T>>;
    private getKey;
    private convert;
    private getMd5;
    protected levenshtien: (p1: string, p2: string) => LevenshteinResponse;
    private guess_sign;
    protected abstract initCode: () => Observable<ExpressCompanyCode[]>;
    codeMap: ExpressCompanyCode[];
    codes: Set<string>;
    protected abstract _init?: () => Observable<any>;
    init: () => Observable<this>;
    protected fixCode: (param: QueryParam) => QueryParam;
}
export {};
