"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yaml = require("yamljs");
const nacos_1 = require("nacos");
const fromPairs = require("lodash/fp/fromPairs");
const rxjs_1 = require("rxjs");
var SimpleType;
(function (SimpleType) {
    SimpleType[SimpleType["Array"] = 1] = "Array";
    SimpleType[SimpleType["Object"] = 2] = "Object";
    SimpleType[SimpleType["Other"] = 3] = "Other";
})(SimpleType || (SimpleType = {}));
class RemoteConfig {
    constructor(option) {
        this.options = [];
        this.local = {};
        this.clients = new Map();
        this._config = {};
        this.init = async () => {
            this.clients = this.options.reduce((result, option) => {
                const client = new nacos_1.NacosConfigClient({
                    serverAddr: `${option.address}:${option.port}`,
                    namespace: option.namespace,
                });
                result.set(option, client);
                return result;
            }, this.clients);
            this._config = { ...(await this.fetch()), ...this.local };
            this._configMap = this.createConfigInterface(this._config);
            for (const [option] of this.clients.entries()) {
                if (option.subscribe) {
                    this.subscribe(option.tag);
                }
            }
            return this;
        };
        this.fetch = async () => {
            const list = [];
            for (const [option, client] of this.clients.entries()) {
                list.push(client.getConfig(option.name, option.group).then(s => {
                    const tmp = {};
                    tmp[option.tag] = (option.format === 'yaml' ? yaml : JSON).parse(s);
                    return tmp;
                }));
            }
            return Promise.all(list).then(configs => configs.reduce((result, config) => ({ ...result, ...config }), {}));
        };
        this.get = (path) => {
            return this._configMap[path];
        };
        this.createConfigInterface = (conf) => fromPairs(this.toEntries(JSON.parse(JSON.stringify(conf))));
        this.toEntries = (obj, type = SimpleType.Object, parent = null) => {
            if (type === SimpleType.Other)
                return [];
            const getKey = (key, type) => `${parent ? `${parent}.` : ''}${type === SimpleType.Array ? `[${key}]` : key}`;
            const getType = (val) => typeof val === 'object'
                ? val instanceof Array
                    ? SimpleType.Array
                    : SimpleType.Object
                : SimpleType.Other;
            const map = parent === null
                ? Object.entries(obj)
                : Object.entries(obj).map(([key, val]) => [getKey(key, type), val]);
            const tmp = [];
            for (const [key, target] of map) {
                const _type = getType(target);
                if (_type !== SimpleType.Other) {
                    tmp.push(...this.toEntries(target, _type, key));
                }
            }
            return [...map, ...tmp];
        };
        this.subscribe = (path, callback) => {
            this.getListenerByPath(path).subscribe(callback ||
                ((tmp) => {
                    return;
                }));
        };
        this.listener = new Map();
        this.getClientByPath = (path) => {
            const tag = path.split('.').shift();
            for (const [option, client] of this.clients.entries()) {
                if (option.tag === tag) {
                    return { option, client };
                }
            }
            return null;
        };
        this.close = () => {
            for (const client of this.clients.values()) {
                client.close();
            }
        };
        this.getListenerByPath = (path) => {
            const { option, client } = this.getClientByPath(path);
            if (!client)
                return null;
            if (!this.listener.has(client)) {
                const subject = new rxjs_1.Subject();
                const listener = {};
                listener[path] = subject;
                this.listener.set(client, listener);
                //console.log(option.name);
                client.subscribe({ dataId: option.name, group: option.group }, (content) => {
                    const conf = (option.format === 'yaml' ? yaml : JSON).parse(content);
                    const tmp = {};
                    tmp[option.tag] = conf;
                    const newConf = { ...this._config, ...tmp };
                    const newMap = this.createConfigInterface(newConf);
                    Object.entries(listener).map(([path, subject]) => {
                        const pre = this._configMap[path];
                        const last = newMap[path];
                        if (pre && last && JSON.stringify(pre) !== JSON.stringify(last)) {
                            subject.next(last);
                        }
                    });
                    this._config = newConf;
                    this._configMap = newMap;
                });
            }
            const result = this.listener.get(client);
            if (!result[path]) {
                result[path] = new rxjs_1.Subject();
            }
            return result[path];
        };
        if (typeof option === 'string') {
            this.local = yaml.load(option);
            this.options = this.local.nacos || [];
        }
        else
            this.options.push(option);
    }
    get map() {
        return this._configMap;
    }
}
exports.RemoteConfig = RemoteConfig;
RemoteConfig._instance = new Map();
RemoteConfig.create = async (option) => {
    const k = JSON.stringify(option);
    const result = RemoteConfig._instance.has(k)
        ? RemoteConfig._instance.get(k)
        : await new RemoteConfig(option).init();
    RemoteConfig._instance.set(k, result);
    RemoteConfig.default = RemoteConfig.default || result;
    return result;
};
